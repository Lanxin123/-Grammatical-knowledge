POD是Plain old data的缩写，它是一个struct或者类，且不包含构造函数、析构函数以及虚函数。

维基百科给出了更加详细的解释：

C++的POD类型或者是一个标量值，或者是一个POD类型的类。
POD class没有用户定义的析构函数、拷贝构造函数和非静态的非POD类型的数据成员。
而且，POD class必须是一个aggregate，没有用户定义的构造函数，没有私有的或者保护的非静态数据，
没有基类或虚函数。它只是一些字段值的集合，没有使用任何封装以及多态特性。

在 C++11 之前，此代码段是不可复制的类型的惯例形式。
struct noncopyable  
{  
  noncopyable() {};  
  
private:  
  noncopyable(const noncopyable&);  
  noncopyable& operator=(const noncopyable&);  
};  
但是，它具有几个问题：
复制构造函数必须以私有方式进行声明以隐藏它，但因为它进行了完全声明，所以会阻止自动生成默认构造函数。 如果你需要默认构造函数，则必须显式定义一个（即使它不执行任何操作）。
即使显式定义的默认构造函数不执行任何操作，编译器也会将它视为重要内容。 其效率低于自动生成的默认构造函数，并且会阻止 noncopyable 成为真正的 POD 类型。
尽管复制构造函数和复制赋值运算符在外部代码中是隐藏的，但成员函数和 noncopyable 的友元仍可以看见并调用它们。 如果它们进行了声明但是未定义，则调用它们会导致链接器错误。
虽然这是广为接受的惯例，但是除非你了解用于自动生成特殊成员函数的所有规则，否则意图不明确。

在 C++11 中，不可复制的习语可通过更直接的方法实现。
struct noncopyable  
{  
  noncopyable() =default;  
  noncopyable(const noncopyable&) =delete;  
  noncopyable& operator=(const noncopyable&) =delete;  
};  
请注意如何解决与 C++11 之前的惯例有关的问题：
仍可通过声明复制构造函数来阻止生成默认构造函数，但可通过将其显式设置为默认值进行恢复。
显式设置的默认特殊成员函数仍被视为不重要的，因此性能不会下降，并且不会阻止 noncopyable 成为真正的 POD 类型。
复制构造函数和复制赋值运算符是公共的，但是已删除。 定义或调用已删除函数是编译时错误。
对于了解 =default 和 =delete 的人来说，意图是非常清楚的。 你不必了解用于自动生成特殊成员函数的规则。